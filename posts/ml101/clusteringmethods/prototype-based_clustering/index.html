<!doctype html><html lang=zh data-theme><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>Book Notes: clustering methods - fgg blog</title>
<meta name=description content="注明：
原理部分的内容均来自周志华的西瓜书，真正的大师之作。
其他内容来自开源包文档、开源电子书、ipynb文档等。


    
        #
    
    原型聚类


原型1聚类也称为 “基于原型的聚类(prototype-based clustering)”，此类算法假设聚类结构能够通过一组原型刻画，在现实聚类任务中极为常用。通常情形下，算法先对原型进行初始化，然后对原型进行迭代更新求解。采用不同的原型表示、不同的求解方式，将产生不同的算法。


    
        ##
    
    $k$ 均值聚类算法


给定样本集 $D = {x_1, \ldots, x_m }$ ，“$k$ 均值($k$-means)” 算法针对聚类所得簇划分 $\mathcal{C} = {C_1, \ldots, C_k }$ 最小化平方误差
$$
\tag{9.24}
E = \sum^k_{i=1} \sum_{x \in C_i} ||x - \mu_i||^2_2 ,
$$
其中，$\mu_i = {1 \over |C_i|} \sum_{x \in C_i} x$ 是簇 $C_i$ 的均值向量。直观来看，式(9.24)在一定程度上刻画了簇内样本围绕簇均值向量的紧密程度，$E$ 值越小则簇内样本相似度越高。
最小化式(9.24)并不容易，找到它的最优解需考察样本集 $D$ 的所有可能簇划分，这是一个 NP 难问题2 。因此，$k$ 均值算法采用了贪心策略，通过迭代优化来近似求解式(9.24)。算法流程如下，其中第1行对均值向量进行初始化，在第4-8行与第9-16行依次对当前簇划分及均值向量迭代更新，若迭代更新后聚类结果保持不变，则在第18行将当前的簇划分结果返回。

k 均值算法流程

输入：样本集 $D = {x_1, \ldots, x_m }$ ；"><link rel=icon type=image/x-icon href=https://fgg100y.github.io/favicon.ico><link rel=apple-touch-icon-precomposed href=https://fgg100y.github.io/favicon.png><style>body{visibility:hidden;opacity:0}</style><noscript><style>body{visibility:visible;opacity:1}</style></noscript><link rel=stylesheet href=/css/style.min.184a655c5ad8596648622468e6696abf0cf0a2cf8266df17b4f7a36fe9c97551.css integrity="sha256-GEplXFrYWWZIYiRo5mlqvwzwos+CZt8XtPejb+nJdVE="><link rel=stylesheet href=/css/style.min.c4c04b3ef88e3d619ad4c7ee5e03048422bc55c4fefdc1f07657c1133670aa22.css integrity="sha256-xMBLPviOPWGa1MfuXgMEhCK8VcT+/cHwdlfBEzZwqiI="><link rel=stylesheet href=/css/style.min.21c5d8fe0a79d623b0adc1ce4bd4f6dd2c05cd939c9aaaa966ba7186b1464f4d.css integrity="sha256-IcXY/gp51iOwrcHOS9T23SwFzZOcmqqpZrpxhrFGT00="><link rel=stylesheet href=/css/style.min.863b4356f5ce53525ab2482f84c47476c4618984b9726e576c244225ebda1bcc.css integrity="sha256-hjtDVvXOU1JaskgvhMR0dsRhiYS5cm5XbCRCJevaG8w=" crossorigin=anonymous><script src=/js/script.min.08f04d96386c73c9bf4d160333f8f448c05a6e01c06770542ee0e013954ce930.js type=text/javascript integrity="sha256-CPBNljhsc8m/TRYDM/j0SMBabgHAZ3BULuDgE5VM6TA="></script><link rel=stylesheet href=/css/custom.css></head><body><a class=skip-main href=#main></a><div class=container><header class=common-header><div class=header-top><div class=header-top-left><h1 class="site-title noselect"><a href=/>fgg blog</a></h1><div class=theme-switcher><span class=inline-svg><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-sun-high"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14.828 14.828A4 4 0 109.172 9.172a4 4 0 005.656 5.656z"/><path d="M6.343 17.657l-1.414 1.414"/><path d="M6.343 6.343 4.929 4.929"/><path d="M17.657 6.343l1.414-1.414"/><path d="M17.657 17.657l1.414 1.414"/><path d="M4 12H2"/><path d="M12 4V2"/><path d="M20 12h2"/><path d="M12 20v2"/></svg></span></div><script>const STORAGE_KEY="user-color-scheme",defaultTheme="auto";let currentTheme,switchButton,autoDefinedScheme=window.matchMedia("(prefers-color-scheme: dark)");function switchTheme(){currentTheme=currentTheme==="dark"?"light":"dark",localStorage&&localStorage.setItem(STORAGE_KEY,currentTheme),document.documentElement.setAttribute("data-theme",currentTheme),changeGiscusTheme(currentTheme),document.body.dispatchEvent(new CustomEvent(currentTheme+"-theme-set"))}const autoChangeScheme=e=>{currentTheme=e.matches?"dark":"light",document.documentElement.setAttribute("data-theme",currentTheme),changeGiscusTheme(currentTheme),document.body.dispatchEvent(new CustomEvent(currentTheme+"-theme-set"))};document.addEventListener("DOMContentLoaded",function(){switchButton=document.querySelector(".theme-switcher"),currentTheme=detectCurrentScheme(),currentTheme==="auto"?(autoChangeScheme(autoDefinedScheme),autoDefinedScheme.addListener(autoChangeScheme)):document.documentElement.setAttribute("data-theme",currentTheme),switchButton&&switchButton.addEventListener("click",switchTheme,!1),showContent()});function detectCurrentScheme(){return localStorage!==null&&localStorage.getItem(STORAGE_KEY)?localStorage.getItem(STORAGE_KEY):defaultTheme?defaultTheme:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"}function showContent(){document.body.style.visibility="visible",document.body.style.opacity=1}function changeGiscusTheme(e){function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}</script><ul class="social-icons noselect"><li><a href=https://github.com/FGG100y title=Github rel=me><span class=inline-svg><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-github"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></span></a></li><li><a href=/index.xml title=RSS rel=me><span class=inline-svg><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-rss"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 19m-1 0a1 1 0 102 0 1 1 0 10-2 0"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></span></a></li></ul></div><div class=header-top-right></div></div><nav class=noselect><a href=https://fgg100y.github.io/ title>首页</a>
<a href=https://fgg100y.github.io/posts/ title>归档</a>
<a href=https://fgg100y.github.io/tags/ title>标签</a>
<a href=https://fgg100y.github.io/about/ title>关于</a></nav><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></header><main id=main tabindex=-1><article class="post h-entry"><div class=post-header><header><h1 class="p-name post-title">Book Notes: clustering methods</h1></header><div class="post-info noselect"><div class="post-date dt-published"><time datetime=2020-06-13>2020-06-13</time></div><a class="post-hidden-url u-url" href=/posts/ml101/clusteringmethods/prototype-based_clustering/>/posts/ml101/clusteringmethods/prototype-based_clustering/</a>
<a href=https://fgg100y.github.io/ class="p-name p-author post-hidden-author h-card" rel=me>map[email:1522009317@qq.com name:fmh]</a><div class=post-taxonomies><ul class=post-tags><li><a href=/tags/xgs/>#Xgs</a></li><li><a href=/tags/clutering/>#Clutering</a></li><li><a href=/tags/k-means/>#K-Means</a></li><li><a href=/tags/gmms/>#GMMs</a></li></ul></div></div></div><details class="toc noselect"><summary>Table of Contents</summary><div class=inner><nav id=TableOfContents><ul><li><a href=#原型聚类>原型聚类</a><ul><li><a href=#k-均值聚类算法>$k$ 均值聚类算法</a></li><li><a href=#k-means-in-action>K-Means in Action</a></li><li><a href=#学习向量量化>学习向量量化</a></li></ul></li><li><a href=#高斯混合聚类gmm>高斯混合聚类(GMM)</a><ul><li><a href=#gaussian-mixture-models-in-action>Gaussian Mixture Models in Action</a></li></ul></li></ul></nav></div></details><script>var toc=document.querySelector(".toc");toc&&toc.addEventListener("click",function(){event.target.tagName!=="A"&&(event.preventDefault(),this.open?(this.open=!1,this.classList.remove("expanded")):(this.open=!0,this.classList.add("expanded")))})</script><div class="content e-content"><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>注明：
</span></span><span style=display:flex><span>原理部分的内容均来自周志华的西瓜书，真正的大师之作。
</span></span><span style=display:flex><span>其他内容来自开源包文档、开源电子书、ipynb文档等。
</span></span></code></pre></div><h2 id=原型聚类><div><a href=#%e5%8e%9f%e5%9e%8b%e8%81%9a%e7%b1%bb>#
</a>原型聚类</div></h2><p>原型<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>聚类也称为 “基于原型的聚类(prototype-based clustering)”，此类算法假设聚类结构能够通过一组原型刻画，在现实聚类任务中极为常用。通常情形下，算法先对原型进行初始化，然后对原型进行迭代更新求解。采用不同的原型表示、不同的求解方式，将产生不同的算法。</p><h3 id=k-均值聚类算法><div><a href=#k-%e5%9d%87%e5%80%bc%e8%81%9a%e7%b1%bb%e7%ae%97%e6%b3%95>##
</a>$k$ 均值聚类算法</div></h3><p>给定样本集 $D = {x_1, \ldots, x_m }$ ，“$k$ 均值($k$-means)” 算法针对聚类所得簇划分 $\mathcal{C} = {C_1, \ldots, C_k }$ 最小化平方误差
$$
\tag{9.24}
E = \sum^k_{i=1} \sum_{x \in C_i} ||x - \mu_i||^2_2 ,
$$
其中，$\mu_i = {1 \over |C_i|} \sum_{x \in C_i} x$ 是簇 $C_i$ 的均值向量。直观来看，式(9.24)在一定程度上刻画了簇内样本围绕簇均值向量的紧密程度，$E$ 值越小则簇内样本相似度越高。</p><p>最小化式(9.24)并不容易，找到它的最优解需考察样本集 $D$ 的所有可能簇划分，这是一个 NP 难问题<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> 。因此，$k$ 均值算法采用了贪心策略，通过迭代优化来近似求解式(9.24)。算法流程如下，其中第1行对均值向量进行初始化，在第4-8行与第9-16行依次对当前簇划分及均值向量迭代更新，若迭代更新后聚类结果保持不变，则在第18行将当前的簇划分结果返回。</p><hr><p><code>k 均值算法流程</code></p><hr><p><strong>输入</strong>：样本集 $D = {x_1, \ldots, x_m }$ ；</p><p>​ 聚类簇数 $k$</p><p><strong>过程</strong>：</p><p>1: 从 $D$ 中随机选择 $k$ 个样本作为初始均值向量 ${\mu_1, \ldots, \mu_k }$</p><p>2: <strong>repeat</strong></p><p>3: 令 $C_i = \phi \quad (1 \le i \le k)$</p><p>4: <strong>for</strong> $j = 1, 2, \ldots, m$ <strong>do</strong></p><p>5: 计算样本 $x_j$ 与各个均值向量 $\mu_i \ (1 \le i \le k)$ 的距离：$d_{ji} = ||x_j - \mu_i||_2$ ；</p><p>6: 根据距离最近的均值向量确定 $x_j$ 的簇标记<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>：$\lambda_j = \text{argmin}<em>{i \in {1, 2, \ldots, k}} d</em>{ji}$ ；</p><p>7: 将样本 $x_j$ 划入相应的簇：$C_{\lambda_j} = C_{\lambda_j} \cup {x_j}$ ；</p><p>8: <strong>end for</strong></p><p>9: <strong>for</strong> $i = 1, 2, \ldots, k$ <strong>do</strong></p><p>10: 计算新均值向量：$\mu_i&rsquo; = {1 \over |C_i|} \sum_{x \in C_i} x$ ；</p><p>11: <strong>if</strong> $\mu_i&rsquo; \ne \mu_i$ <strong>then</strong></p><p>12: 将当前均值向量 $\mu_i$ 更新为 $\mu_i'$</p><p>13: <strong>else</strong></p><p>14: 保持当前均值向量不变</p><p>15: <strong>end if</strong></p><p>16: <strong>end for</strong></p><p>17: <strong>until</strong> 当前均值向量均未更新</p><p><strong>输出</strong>：簇划分 $\mathcal{C} = {C_1, C_2, \ldots, C_k }$</p><hr><h3 id=k-means-in-action><div><a href=#k-means-in-action>##
</a>K-Means in Action</div></h3><h4 id=finding-the-optimal-number-of-clusters><div><a href=#finding-the-optimal-number-of-clusters>###
</a>Finding the optimal number of clusters</div></h4><p>In general, it will not be easy to know how to set $k$, and the result might be quite bad if you set it to the wrong value (see Figure 9-7).</p><p><img alt="cluster No." src=./images/handson_cluster_numbers.png></p><p>You might be thinking that we could just pick the model with lowest inertia. Unfortunately, the inertia is not a good performance metric when trying to choose $k$ because it keeps getting lower as we increase $k$. Indeed, the more clusters there are, the closer each instance will be to its closest centroid, and therefore the lower the inertia will be (see Figure 9-8: a plot of the inertia as a function of $k$).</p><p><img alt="cluster inertia" src=./images/handson_cluster_inertia.png></p><p>This technique for choosing the best value for the number of clusters is rather coarse. A more precise approach (but more computationally expensive) is to use the <strong>silhouette score</strong>, which is the mean silhouette coefficient (轮廓系数) over all the instances. An instance&rsquo;s silhouette coefficient is equal to $(b - a) / \max(a, b)$, where $a$ is the mean distance to the other instances in the same cluster (i.e., the mean intra-cluster distance) and $b$ is the mean nearest-cluster distance (i.e., the mean distance to the instances of the next cluster, defined as the one that minimizes $b$, excluding the instance&rsquo;s own cluster).</p><p>The silhouette coefficient can vary between -1 and +1.</p><ul><li>silhouette coefficient close to +1 means that the instance is well inside its own cluster and far from other clusters</li><li>silhouette coefficient close to 0 means that it is close to a cluster boundary</li><li>silhouette coefficient close to -1 means that the instance may have been assigned to the wrong cluster</li></ul><p>To compute the silhouette score, you can use sklearn&rsquo;s <code>silhouette_score()</code> function:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff6ac1>from</span> sklearn.metrics <span style=color:#ff6ac1>import</span> silhouette_score
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e># give it all the instances in the dataset</span>
</span></span><span style=display:flex><span><span style=color:#78787e># and the labels they were assigned</span>
</span></span><span style=display:flex><span>silhouette_score(X, kmeans_model<span style=color:#ff6ac1>.</span>labels_)
</span></span></code></pre></div><p>We can also compare the silhouette scores for different numbers of clusters (see Figure 9-9):</p><p><img alt="silhouette scores" src=./images/handson_cluster_silhouette_scores.png></p><p>As the Figure 9-9 shows, this visualization is much richer than the previous one: although it confirms that $k = 4$ is a very good choice, it also underlines the fact that $k = 5$ is quite good as well, and much better than $k > 5$. This is not visible when comparing the inertias.</p><p><strong>silhouette diagram</strong></p><p>An even more informative visualization is obtained when you plot every instance&rsquo;s silhouette coefficient, sorted by the cluster they are assigned to and by the value of the coefficient. This is called a <em>silhouette diagram</em> (see Figure 9-10). Each diagram contains one knife shape per cluster. The shape&rsquo;s height indicates the number of instances the cluster contains, and its width represents the sorted silhouette coefficients of the instances in the cluster (wider is better). The dashed line indicated the mean silhouette coefficient.</p><p><img alt="silhouette coefficient sorted" src=./images/handson_cluster_silhouette_coefficients_sorted.png></p><p>The dashed line represents the mean silhouette score for each number of clusters. When most of the instances in a cluster have a lower coefficient than this score, then the cluster is rather bad since this means its instances are much too close to other clusters (such as when $k = 3, k = 6$). But when $k =4$ or $k = 5$ , the clusters look pretty good: most instances extend beyond the dashed line. When $k = 4$ , the cluster at index 1 is rather big. When $k = 5$ , all clusters have similar sizes. So, even though the overall silhouette score from $k=4$ is slightly greater than for $k=5$ , it seems like a good idea to use $k=5$ to get clusters of similar sizes.</p><h4 id=limits-of-k-means><div><a href=#limits-of-k-means>###
</a>Limits of K-Means</div></h4><p>Despite its many merits, most notably being fast and scalable, K-Means is not perfect. As we saw, it is necessary to run the algorithm several times to avoid suboptimal solutions, plus you need to specify the number of clusters, which can be quite a hassle. Moreover, K-Means does not behave very well when the clusters have varying sizes, different densities, or non-spherical shapes (see Figure 9-11).</p><p><img alt="cluster shapes" src=./images/handson_cluster_shapes.png></p><p>As Figure 9-11 shows, neither of these solutions is any good (the solution on the right is just terrible even though its inertia is lower). So, depending on the data, different clustering algorithms may perform better. On these types of elliptical clusters, <em>Gaussian mixture models</em> work great.</p><h3 id=学习向量量化><div><a href=#%e5%ad%a6%e4%b9%a0%e5%90%91%e9%87%8f%e9%87%8f%e5%8c%96>##
</a>学习向量量化</div></h3><p>与 $k$ 均值算法类似，“学习向量量化(Learning Vector Quantization, LVQ)” 也是试图找到一组原型向量来刻画聚类结构，但与一般聚类算法不同的是，LVQ 假设数据样本带有类别标记<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> ，学习过程利用样本的这些监督信息来辅助聚类。</p><p>给定样本集 $D = {(x_1, y_1), \ldots, (x_m, y_m) }$ ，每个样本 $x_j$ 是由 $n$ 个属性描述的特征向量 $(x_{j1}; x_{j2}; \ldots;x_{jn})$ ， $y_j \in \mathcal{Y}$ 是样本 $x_j$ 的类别标记。LVQ 的目标是学得一组 $n$ 维原型向量 ${p_1, p_2, \ldots, p_q }$ ，每个原型向量代表一个聚类簇，簇标记 $t_i \in \mathcal{Y}$ 。</p><p><code>LVQ 算法</code> 描述如下：算法第1行先对原型向量进行初始化，例如对第q个簇可以从类别标记为 $t_q$ 的样本中随机选取一个作为原型向量。算法第2-12行对原型向量进行迭代优化。在每一轮迭代中，算法随机选取一个有标记的训练样本，找出与其距离最近的原型向量，并根据两者的类别标记是否一致来对原型向量进行相应的更新。在第12行中，若算法的停止条件已满足（例如达到最大迭代轮数，或原型向量趋于稳定），则将当前原型向量作为最终结果返回。</p><hr><p><code>LVQ 算法</code></p><hr><p><strong>输入</strong>：样本集 $D = {(x_1, y_1), \ldots, (x_m, y_m) }$ ；</p><p>​ 原型向量个数 $q$ ，各原型向量预设类别标记 ${ t_1, t_2, \ldots, t_q}$ ；</p><p>​ 学习率 $\eta \in (0, 1)$ .</p><p><strong>过程</strong>：</p><p>01: 初始化一组原型向量 ${p_1, p_2, \ldots, p_q }$</p><p>02: <strong>repeat</strong></p><p>03: 从样本集 $D$ 随机选取样本 $(x_j, y_j)$ ；</p><p>04: 计算样本 $x_j$ 与 $p_i (1 \le i \le q)$ 的距离：$d_{ji} = ||x_j - p_i||_2$ ；</p><p>05: 找出与 $x_j$ 距离最近的原型向量 $p_{i*}$ ，$i* = \text{argmin}<em>{i \in {1, 2, \ldots, q}} d</em>{ji}$ ；</p><p>06: <strong>if</strong> $y_j = t_{i*}$ <strong>then</strong></p><p>07: $p&rsquo; = p_{i*} + \eta \cdot (x_j - p_{i*})$</p><p>08: <strong>else</strong></p><p>09: $p&rsquo; = p_{i*} - \eta \cdot (x_j - p_{i*})$</p><p>10: <strong>end if</strong></p><p>11: 将原型向量 $p_{i*}$ 更新为 $p'$</p><p>12: <strong>until</strong> 满足停止条件</p><p><strong>输出</strong>：原型向量 ${p_1, p_2, \ldots, p_q }$</p><hr><p>显然，LVQ 的关键是第6-10行，即如何更新原型向量。直观上看，对样本 $x_j$ ，若最近的原型向量 $p_{i*}$ 与 $x_j$ 的类别标记相同，则令 $p_{i*}$ 与 $x_j$ 的方向靠拢，如<code>LVQ 算法</code> 第7行所示，此时新原型向量为
$$
\tag{9.25}
p&rsquo; = p_{i*} + \eta \cdot (x_j - p_{i*}) ,
$$
$p&rsquo;$ 与 $x_j$ 之间的距离为
$$
\begin{eqnarray}
||p&rsquo; - x_j||<em>2
&=& ||p</em>{i*} + \eta \cdot (x_j - p_{i*}) - x_j||<em>2 \
\
\tag{9.26}
&=& (1 - \eta) \cdot ||p</em>{i*} - x_j||<em>2 .
\end{eqnarray}
$$
令学习率 $\eta \in (0, 1)$ ，则原型向量 $p</em>{i*}$ 在更新为 $p&rsquo;$ 之后将更接近 $x_j$ 。</p><p>类似的，若 $p_{i*}$ 与 $x_j$ 的类别标记不同，则更新后的原型向量与 $x_j$ 之间的距离将增大 $(1 + \eta) \cdot ||p_{i*} - x_j||_2$ ，从而更远离 $x_j$ 。</p><p>在学得一组原型向量 ${p_1, p_2, \ldots, p_q }$ 后，即可实现对样本空间 $\cal{X}$ 的簇划分。对任意样本 $x$ ，它将被划入与其距离最近的原型向量所代表的簇中；换言之，每个原型向量 $p_i$ 定义了一个与之相关的一个区域 $R_i$<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> ，该区域中每个样本与 $p_i$ 的距离不大于它与其他原型向量 $p_{i&rsquo;} (i \ne i&rsquo;)$ 的距离，即
$$
\tag{9.27}
R_i = {x \in \mathcal{X} \quad \text{so that} \quad ||x - p_i||<em>2 \le ||x - p</em>{i&rsquo;}||_2, i&rsquo; \ne i } .
$$
由此形成了对样本空间 $\cal{X}$ 的簇划分 ${R_1, R_2, \ldots, R_q }$ ，该划分通常称为 “Voronoi 剖分(Voronoi tessellation)” 。</p><h2 id=高斯混合聚类gmm><div><a href=#%e9%ab%98%e6%96%af%e6%b7%b7%e5%90%88%e8%81%9a%e7%b1%bbgmm>#
</a>高斯混合聚类(GMM)</div></h2><p>与 $k$ 均值、LVQ 用原型向量类刻画聚类结构不同，高斯混合(Mixture-of-Gaussian) 聚类算法采用概率模型来表达聚类原型。</p><blockquote><p>简单回顾 | 多元高斯分布</p><p>多元高斯分布的定义：对 $n$ 维样本空间 $\cal{X}$ 中随机向量 $x$ ，若 $x$ 服从高斯分布，其概率密度函数为
$$
\tag{9.28}
p(x) = {1 \over {(2 \pi)^{n \over 2} |\Sigma|^{1 \over 2}}} \exp {\bigg(-{1\over2}(x - \mu)^{\mathsf{T}} \Sigma^{-1} (x - \mu) \bigg)} ,
$$
其中，$\exp(x) = e^x$ ，$\mu$ 是 $n$ 维均值向量，$\Sigma$ 是 $n \times n$ 的协方差矩阵(并且是“对称正定矩阵”， 正定矩阵意思是其eigenvalues都大于零)，$|\Sigma|$ 是其行列式，$\Sigma^{-1}$ 是其逆矩阵。由式(9.28)可看出，高斯分布完全由均值向量 $\mu$ 和协方差矩阵 $\Sigma$ 这两个参数确定。为了明确显示高斯分布与相应参数的依赖关系，将概率密度函数记为 $p(x | \mu, \Sigma)$ 。</p></blockquote><p>我们可以定义高斯混合分布<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>
$$
\tag{9.29}
p_{\cal{M}} (x) = \sum^k_{i=1} \alpha_i \cdot p(x | \mu_i, \Sigma_i) ,
$$
该分布共由 $k$ 个混合成分组成，每个混合成分对应一个高斯分布。其中 $\mu_i$ 与 $\Sigma_i$ 是第 $i$ 个高斯混合成分的参数，而 $\alpha_i > 0$ 为相应的 “混合系数(mixture coefficient)” ，且有 $\sum^k_{i=1} \alpha_i = 1$ 。</p><p>假设样本的生成过程由高斯混合分布给出：首先，根据 $\alpha_1, \alpha_2, \ldots, \alpha_k$ 定义的先验分布选择高斯混合成分，其中 $\alpha_i$ 为选择第 $i$ 个混合成分的概率；然后，根据被选择的混合成分的概率密度函数进行采样，从而生成相应的样本。</p><p>若训练集 $D = {x_1, \ldots, x_m }$ 由上述过程生成，令随机变量 $z_j \in {1, 2, \ldots, k }$ 表示生成样本 $x_j$ 的高斯混合成分，其取值未知。显然，$z_j$ 的先验概率 $P(z_j = i)$ 对应于 $\alpha_i (i = 1, 2, \ldots, k)$ 。根据贝叶斯定理，$z_j$ 的后验概率分布对应于
$$
\begin{eqnarray}
p_{\mathcal{M}}(z_j = i | x_j)
&=& \frac{P(z_j = i) \cdot p_{\mathcal{M}}(x_j | z_j = i)}{p_{\mathcal{M}}(x_j)} \
\
\tag{9.30} \label{eq_bayes_posterior}
&=& \frac{\alpha_i \cdot p(x_j | \mu_i, \Sigma_i) }{\sum^k_{l=1} \alpha_l \cdot p(x_j | \mu_l, \Sigma_l)} .
\end{eqnarray}
$$
换言之，$p_{\mathcal{M}}(z_j = i | x_j)$ 给出了样本 $x_j$ 由第 $i$ 个高斯混合成分生成的后验概率。为方便叙述，将其简记为 $\gamma_{ji} (i = 1, 2, \ldots, k)$ 。</p><p>当高斯混合分布(式9.29)已知时，高斯混合聚类将把样本集 $D$ 划分为 $k$ 个簇 $\mathcal{C} = {C_1, \ldots, C_k }$ ，每个样本 $x_j$ 的簇标记 $\lambda_j$ 如下确定：
$$
\tag{9.31} \label{eq_cluster_idx}
\lambda_j
= \underset{i \in {1, 2, \ldots, k }}{\operatorname{argmax}} \gamma_{ji} .
$$
因此，从原型聚类的角度来看，高斯混合聚类是采用概率模型(高斯分布)对原型进行刻画，簇划分则由原型对应后验概率确定。</p><p>那么，对于式(9.29)，模型参数 ${\alpha_i, \mu_i, \Sigma_i | 1 \le i \le k }$ 如何求解呢？显然，给定样本集 $D$ ，可采用极大似然估计，即最大化似然(对数似然)
$$
\begin{eqnarray}
LL(D)
&=& \ln \bigg(\prod^m_{j=1} p_{\mathcal{M}}(x_j) \bigg) \
\
\tag{9.32}
&=& \sum^m_{j=1} \ln \bigg(\sum^k_{i=1} \alpha_i \cdot p(x_j | \mu_i, \Sigma_i) \bigg) ,
\end{eqnarray}
$$
常用 EM 算法<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> 进行迭代优化求解，得到
$$
\tag{9.34}
\mu_i = \frac{\sum^m_{j=1} \gamma_{ji} x_j}{\sum^m_{j=1} \gamma_{ji}} ,
$$
即各<strong>混合成分的均值</strong>可通过样本加权平均来估计，样本权重是每个样本属于该成分的后验概率。类似的，对<strong>混合成分的协方差矩阵</strong>有
$$
\tag{9.35}
\Sigma_i = \frac{\sum^m_{j=1} \gamma_{ji}(x_j - \mu_i)(x_j - \mu_i)^{\mathsf{T}}}{\sum^m_{j=1} \gamma_{ji}} .
$$
对应混合系数 $\alpha_i$ ，除了要最大化 $LL(D)$ ，还需要满足 $\alpha_i \le 0,\sum^k_{i=1} \alpha_i = 1$ 。考虑解 $LL(D)$ 的拉格朗日形式
$$
\tag{9.36}
LL(D) + \lambda \bigg(\sum^k_{i=1} \alpha_i - 1 \bigg) ,
$$
其中 $\lambda$ 为拉格朗日乘子。由式(9.36)对 $\alpha_i$ 的导数为 0，有
$$
\tag{9.37}
\sum^m_{j=1} \frac{p(x_j | \mu_i, \Sigma_i)}{\sum^k_{l=1} \alpha_l \cdot p(x_j | \mu_l, \Sigma_l)} + \lambda = 0 ,
$$
两边同乘以 $\alpha_i$ ，对所有样本求和可知 $\lambda = -m$ ，有
$$
\tag{9.38}
\alpha_i = {1 \over m} \sum^m_{j=1} \gamma_{ji} ,
$$
即每个<strong>高斯成分的混合系数</strong>由样本属于该成分的平均后验概率确定。</p><p>由上述推导即可获得高斯混合模型的 EM 算法：在每步迭代中，先根据当前参数来计算每个样本属于每个高斯混合成分的后验概率 $\gamma_{ji}$ （E 步），再根据式(9.34)、(9.35)和(9.38)更新模型参数 ${\alpha_i, \mu_i, \Sigma_i | 1 \le i \le k }$ （M 步）。</p><hr><p><code>高斯混合聚类算法</code></p><hr><p><strong>输入</strong>：样本集 $D = {x_1, \ldots, x_m }$ ；</p><p>​ 高斯混合成分个数 $k$ 。</p><p><strong>过程</strong>：</p><p>01: 初始化高斯混合分布的模型参数 ${\alpha_i, \mu_i, \Sigma_i | 1 \le i \le k }$</p><p>02: <strong>repeat</strong></p><p>03: <strong>for</strong> $j = 1, 2, \ldots, m$ <strong>do</strong></p><p>04: 根据式($\ref{eq_bayes_posterior}$)计算样本 $x_j$ 由各混合成分生成的后验概率，即 $\gamma_{ji} = p_{\mathcal{M}}(z_j = i | x_j) (1 \le i \le k)$</p><p>05: <strong>end for</strong></p><p>06: <strong>for</strong> $i = 1, 2, \ldots, k$ <strong>do</strong></p><p>07: 计算新的均值向量：$\mu_i&rsquo; = \frac{\sum^m_{j=1} \gamma_{ji} x_j}{\sum^m_{j=1} \gamma_{ji}}$</p><p>08: 计算新的协方差矩阵：$\Sigma_i&rsquo; = \frac{\sum^m_{j=1} \gamma_{ji}(x_j - \mu_i)(x_j - \mu_i)^{\mathsf{T}}}{\sum^m_{j=1} \gamma_{ji}}$</p><p>09: 计算新的混合系数：$\alpha_i&rsquo; = {1 \over m} \sum^m_{j=1} \gamma_{ji}$</p><p>10: <strong>end for</strong></p><p>11: 将模型参数 ${\alpha_i, \mu_i, \Sigma_i | 1 \le i \le k }$ 更新为 ${\alpha_i&rsquo;, \mu_i&rsquo;, \Sigma_i&rsquo; | 1 \le i \le k }$</p><p>12: <strong>until</strong> 满足停止条件</p><p>13: $C_i = \phi (1 \le i \le k)$</p><p>14: <strong>for</strong> $j = 1, 2, \ldots, m$ <strong>do</strong></p><p>15: 根据式($\ref{eq_cluster_idx}$)确定 $x_j$ 的簇标记 $\lambda_j$ ;</p><p>16: 将 $x_j$ 划入相应的簇：$C_{\lambda_j} = C_{\lambda_j} \cup {x_j }$</p><p>17: <strong>end for</strong></p><p><strong>输出</strong>：簇划分 $\mathcal{C} = {C_1, C_2, \ldots, C_k }$</p><hr><h3 id=gaussian-mixture-models-in-action><div><a href=#gaussian-mixture-models-in-action>##
</a>Gaussian Mixture Models in Action</div></h3><p>A <em>Gaussian mixture model (GMM)</em> is a probabilistic model that assumes that the instances were generated from a mixture of several Gaussian distributions whose parameters are unknown. All the instances generated from a single Gaussian distribution from a cluster that typically looks like an ellipsoid with different shape, sizes, density and orientation.</p><p>There are several GMM variants. In the simplest variant, implemented in the <code>GaussianMixture</code> class, you must know in advance the number $k$ of Gaussian distributions. The dataset $\bf{X}$ is assumed to have been generated through the following probabilistic process:</p><ul><li>For each instance, a cluster is picked randomly from among $k$ clusters. The probability of choosing the $j^{th}$ cluster is defined by the cluster&rsquo;s weight, $\phi^{(j)}$. The index of the cluster chosen for the $i^{th}$ instance is noted as $z^{(i)}$ .</li><li>If $z^{(i)} = j$, meaning the $i^{th}$ instance has been assigned to the $j^{th}$ cluster, the location $\bf{x}^{(i)}$ of this instance is sampled randomly from the Gaussian distribution with mean $\mathbf{\mu}^{(j)}$ and covariance matrix $\mathbf{\Sigma}^{(j)}$ . This is noted $\mathbf{x}^{(i)} \sim \mathcal{N}(\mathbf{\mu}^{(j)}, \mathbf{\Sigma}^{(j)})$.</li></ul><p>This generative process can be represented as a graphical model (Figure 9-16).</p><p><img alt=gmm src=./images/handson_cluster_gmm.png></p><h4 id=gmm-for-clustering><div><a href=#gmm-for-clustering>###
</a>GMM for Clustering</div></h4><p>So, what can you do with such a model? Well, given the dataset $\bf{X}$ , you typically want to start by estimating the weights $\phi$ and all the distribution parameters $\mathbf{\mu}^{(1)}$ to $\mathbf{\mu}^{(k)}$ and $\mathbf{\Sigma}^{(1)}$ to $\mathbf{\Sigma}^{(k)}$ . Sklearn&rsquo;s <code>GaussianMixture</code> class makes this super easy:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff6ac1>from</span> sklearn.mixture <span style=color:#ff6ac1>import</span> GaussianMixture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e># This class relies on the Expectation-Maximization(EM) algorithm,</span>
</span></span><span style=display:flex><span><span style=color:#78787e># which has many similarities with K-Means algorithm:</span>
</span></span><span style=display:flex><span><span style=color:#78787e># it also initializes the cluster parameters randomly,</span>
</span></span><span style=display:flex><span><span style=color:#78787e># then it repeats two steps until convergence:</span>
</span></span><span style=display:flex><span><span style=color:#78787e># 	* first assigning instances to clusters (E step)</span>
</span></span><span style=display:flex><span><span style=color:#78787e># 	* then updating the clusters (M step)</span>
</span></span><span style=display:flex><span><span style=color:#78787e># Think of EM as a generalization of K-Means that not only finds</span>
</span></span><span style=display:flex><span><span style=color:#78787e># 	* the clusters (mu_1 to mu_k), but also</span>
</span></span><span style=display:flex><span><span style=color:#78787e># 	* their size, shape, and orientation (Sigma_1 to Sigma_k), as well as</span>
</span></span><span style=display:flex><span><span style=color:#78787e># 	* their relative weights (phi_1 to phi_k)</span>
</span></span><span style=display:flex><span><span style=color:#78787e># Unlike K-Means, EM uses soft clustering assignments, not hard assignments,</span>
</span></span><span style=display:flex><span><span style=color:#78787e># unfortunately, just like K-Means, EM can end up converging to poor solutions,</span>
</span></span><span style=display:flex><span><span style=color:#78787e># so it needs to be run several times, keeping only the best solution. This is</span>
</span></span><span style=display:flex><span><span style=color:#78787e># why we set n_init=10. (By default, n_init=1)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>gmm <span style=color:#ff6ac1>=</span> GaussianMixture(n_components<span style=color:#ff6ac1>=</span><span style=color:#ff9f43>3</span>, n_init<span style=color:#ff6ac1>=</span><span style=color:#ff9f43>10</span>)
</span></span><span style=display:flex><span>gmm<span style=color:#ff6ac1>.</span>fit(X)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>print</span>(gmm<span style=color:#ff6ac1>.</span>converged_) 		<span style=color:#78787e># True or False</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>print</span>(gmm<span style=color:#ff6ac1>.</span>n_iter_) 			<span style=color:#78787e># how many EM iterations using</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>print</span>(gmm<span style=color:#ff6ac1>.</span>weights_)			<span style=color:#78787e># cluster weights</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>print</span>(gmm<span style=color:#ff6ac1>.</span>means_) 			<span style=color:#78787e># means vectors</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>print</span>(gmm<span style=color:#ff6ac1>.</span>covariances_) 	<span style=color:#78787e># covariance matrices</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e># now that the gmm can easily</span>
</span></span><span style=display:flex><span><span style=color:#78787e># 1. assign each instance to the most likely cluster (hard clustering)</span>
</span></span><span style=display:flex><span><span style=color:#78787e># 2. estimate the probability that it belongs to a particular cluster (soft clustering)</span>
</span></span><span style=display:flex><span>res_hc <span style=color:#ff6ac1>=</span> gmm<span style=color:#ff6ac1>.</span>predict(X) 			<span style=color:#78787e># hard clustering</span>
</span></span><span style=display:flex><span>res_sc <span style=color:#ff6ac1>=</span> gmm<span style=color:#ff6ac1>.</span>predict_proba(x) 		<span style=color:#78787e># soft clustering</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e># estimate the density of the model at any given location</span>
</span></span><span style=display:flex><span>log_pdf_scores <span style=color:#ff6ac1>=</span> gmm<span style=color:#ff6ac1>.</span>score_samples(X)
</span></span><span style=display:flex><span>pdf_values <span style=color:#ff6ac1>=</span> np<span style=color:#ff6ac1>.</span>exp(log_pdf_scores)
</span></span><span style=display:flex><span><span style=color:#78787e># these pdf_values are not probabilities, but probability densities,</span>
</span></span><span style=display:flex><span><span style=color:#78787e># to estimate the probability that an instance will fall within a</span>
</span></span><span style=display:flex><span><span style=color:#78787e># particular region, one would have to integrate the PDF over that region.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e># A GMM is a generative model, meaning you can sample new instances form it</span>
</span></span><span style=display:flex><span><span style=color:#78787e># (note that they are ordered by cluster index):</span>
</span></span><span style=display:flex><span>X_new, y_new <span style=color:#ff6ac1>=</span> gmm<span style=color:#ff6ac1>.</span>sample(<span style=color:#ff9f43>6</span>)
</span></span></code></pre></div><p>Figure 9-17 shows the cluster means, the decision boundaries (dashed lines), and the density contours of this model.</p><p><img alt="trained gmm" src=./images/handson_trained_gmm.png></p><p>It seems the algorithm clearly found an excellent solution. Of course, we made its task easy by generating the data using a set of 2D Gaussian distributions (real life data is not always so Gaussian and low-dimensional). We also gave the algorithm the correct number of clusters.</p><p>When there are many dimensions, or many clusters, or few instances, EM can struggle to converge to the optimal solution. In such cases, we might need to reduce the difficulty of the task by limiting the number of parameters that the algorithm has to learn. One way to do this is to constraints the covariance matrices (limited the range of shapes and orientations the clusters can have) by setting the <code>covariance_type</code> hyperparameter to one of the following values:</p><ul><li><p><code>covariance_type="spherical"</code> :</p><p>All clusters must be spherical, but can have different diameters (i.e., different variances)</p></li><li><p><code>covariance_type="diag"</code> :</p><p>Clusters can take on any ellipsoidal shape of any size, but ellipsoid&rsquo;s axes must parallel to the coordinate axes</p></li><li><p><code>covariance_type="tied"</code> :</p><p>All the cluster must have the same ellipsoidal shape, size, and orientation (i.e., all share one covariance matrix)</p></li><li><p><code>covariance_type="full"</code> : (by default)</p><p>This means that each cluster can take on any shape, size, and orientation. If there is a large numbers of features, it will not scale well.</p></li></ul><p><img alt="constrained gmm" src=./images/handson_constrained_gmm.png></p><h4 id=gmm-for-anomaly-detection><div><a href=#gmm-for-anomaly-detection>###
</a>GMM for Anomaly Detection</div></h4><p><em>Anomaly detection</em> (a.k.a., <em>outlier detection</em>) is the task of detecting instances that deviate strongly from the norm. Using GMM for anomaly detection is quite simple: any instance located in a low-density region can be considered an anomaly. So one must define what density threshold to use.</p><p>For example, in a manufacturing company that tries to detect defective products, the ratio of defective products is usually well known. Say it is equal to 4%. You then set the density threshold ($\rho$) to be the value that results in having 4% of the instances located in areas below $\rho$:</p><ul><li>If getting too many false positives (good products flagged as defective), lower the value of $\rho$</li><li>If getting too many false negatives (defective products not flag as defective), lower the value of $\rho$</li></ul><p>This is the usual precision/recall trade-off<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup> .</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#78787e># defective products example</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>densities <span style=color:#ff6ac1>=</span> gmm<span style=color:#ff6ac1>.</span>score_samlpe(X)
</span></span><span style=display:flex><span>density_threshold <span style=color:#ff6ac1>=</span> np<span style=color:#ff6ac1>.</span>percentile(densities, <span style=color:#ff9f43>4</span>)
</span></span><span style=display:flex><span>anomalies <span style=color:#ff6ac1>=</span> X[densities <span style=color:#ff6ac1>&lt;</span> density_threshold]
</span></span></code></pre></div><p><img alt="anomaly detection" src=./images/handson_gmm_anomaly_detection.png></p><h4 id=selecting-the-number-of-clusters><div><a href=#selecting-the-number-of-clusters>###
</a>Selecting the Number of Clusters</div></h4><p>With K-Means, we could use the inertia or the silhouette score to select the appropriate number of clusters. But with GMM, it is not possible to use these metrics because they are not reliable when the clusters are not spherical or have different sizes. Instead, we can try to find the model that minimizes a <em>theoretical information criterion</em>, such the <em>Bayes information criterion (BIC)</em> or the <em>Akaike information criterion (AIC)</em>, defined as follows
$$
\begin{eqnarray}
BIC &=& \log(m)p - 2 \log(\hat{L}) \
\
AIC &=& 2p - 2 \log(\hat{L})
\end{eqnarray}
$$
where $m$ is the number of instances, $p$ is the number of parameters learned by the model, and $\hat{L}$ is the maximized value of the <em>likelihood function</em> of the model.</p><p>Both the $BIC$ and $AIC$ penalize models that have more parameters to learn (e.g., more clusters) and reward models that fit the data well. They often end up selecting the same model. When they differ, $BIC$ tends to select simpler model (fewer parameters) while not fit the data quite as well as $AIC$ (especially true for larger datasets).</p><p>To compute the $BIC$ and $AIC$ , call the <code>bic()</code> and <code>aic()</code> methods:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#78787e># gmms contains gmm trained with different k</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>for</span> gmm <span style=color:#ff6ac1>in</span> gmms:
</span></span><span style=display:flex><span>    bic_scores<span style=color:#ff6ac1>.</span>append(gmm<span style=color:#ff6ac1>.</span>bic(x))
</span></span><span style=display:flex><span>    aic_scores<span style=color:#ff6ac1>.</span>append(gmm<span style=color:#ff6ac1>.</span>aic(x))
</span></span></code></pre></div><p><img alt="bic aic metrics" src=./images/handson_gmm_bic_aic_metrics.png></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>“原型” 是指样本空间中具有代表性的点。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>NP hardness problem (<a href=https://wikimili.com/en/NP_(complexity)>non-deterministic polynomial-time</a> hardness): wait&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>$\lambda_j$ 实际是 ${1, 2, \ldots, k }$ 中的某个数，是 $k$ 个不同聚类簇 $\cal{C}$ 的下标，因为 $\text{argmin}_{i \in {1, 2, \ldots, k}} (\text{expression}_i)$ 函数就是返回使得 $\text{expression}$ 最小的那个 $i$ 。&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>SOM 是基于无标记样本的聚类算法，而 LVQ 可看作 SOM 基于监督信息的扩展。SOM（Self-Organizing Map, 自组织映射）网络是一种竞争型学习(competitive learning) 的无监督神经网络，它能将高维输入数据映射到低维空间(通常二维) ，同时保持输入数据在高维空间的拓扑结构，即将高维空间中相似的样本点映射到网络输出层的邻近神经元。&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>竞争型学习是神经网络中常用的一种无监督学习策略，在使用该策略时，网络的输出神经元互相竞争，每一时刻仅有一个竞争获胜的神经元被激活，其他神经元的状态被抑制（“胜者通吃(winner-take-all)原则”）。&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>若将 $R_i$ 中样本全用原型向量 $p_i$ 表示，则可实现数据的 “有损压缩(lossy compression)”，这称为 “向量量化( vector quantization)” ；LVQ 由此而得名。&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>$p_{\cal{M}} (·)$ 也是概率密度函数，$\int {p_{\cal{M}}(x)dx} = 1$.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>Expectation-Maximization 算法(EM，期望最大化算法) 是常用的估计参数隐变量的利器，它是一种迭代式的方法，其核心思想是：若模型参数 $\Theta$ 已知，则可根据训练数据推断出最优隐变量 $\mathbf{Z}$ 的值（E 步）；反之，若 $\mathbf{Z}$ 的值已知，则可方便地对参数 $\Theta$ 做极大似然估计（M 步）。进一步，若我们不是取 $\mathbf{Z}$ 的期望，而是基于$\Theta$ 计算隐变量 $\mathbf{Z}$ 的概率分布 $P(\bf{Z} | X, \Theta)$ ，则 EM 算法的两个步骤是：以当前参数 $\Theta^t$ 推断 $P(\bf{Z} | X, \Theta^t)$ ，并计算对数似然 $LL(\bf{\Theta} | X, Z)$ 关于 $\bf{Z}$ 的期望，即 $\mathbb{E}(\Theta | \Theta^t)$（E 步）；寻找参数最大化期望似然，即 $\Theta^{t+1} = \text{argmax}_{\Theta} \mathbb{E}(\Theta | \Theta^t)$ （M 步）。EM 算法可看作用 “坐标下降法” 来最大化对数似然下界的过程。&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>Evaluate model performance in classification task.&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article><h3 class="read-next-title noselect"></h3><ul class="read-next-posts noselect"><li><a href=/posts/ml101/treebasedmodels/deepforest/>Book Notes: Deep-Forest Model</a></li><li><a href=/posts/ml101/treebasedmodels/treemodels/>Book Notes: Tree-based Models</a></li></ul><div class="pagination post-pagination"><div class="left pagination-item"><a href=/posts/optimazationmethods/sgd/approximate_second-order_methods/>Book Notes: second order approximation (1)</a></div><div class="right pagination-item"><a href=/posts/ml101/treebasedmodels/deepforest/>Book Notes: Deep-Forest Model</a></div></div></main><footer class="common-footer noselect"><ul class=language-select><li>Chinese</li><li><a href=/en/>English</a></li></ul><div class=common-footer-bottom><div style=display:flex;align-items:center;gap:8px>© fmh, 2024</div><div style=display:flex;align-items:center></div><div><a target=_blank rel="noopener noreferrer" href=https://gohugo.io/>Hugo</a>, <a target=_blank rel="noopener noreferrer" href=https://github.com/Junyi-99/hugo-theme-anubis2>Anubis2</a>.<br></div></div><p class="h-card vcard"><a href=https://fgg100y.github.io/ class="p-name u-url url fn" rel=me>map[email:1522009317@qq.com name:fmh]</a></p></footer></div></body></html>